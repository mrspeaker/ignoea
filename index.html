<!DOCTYPE html>
<html>
<head>
	<title>igonea</title>
	<style>
		body {
			margin: 0;
			padding: 0;
		}
		canvas {
			width: 100%;
			height: 100%;
		}
	</style>
</head>
<body>
	<script src="vendor/three.min.js"></script>
	<script src="vendor/OBJLoader.js"></script>
	<script src="vendor/ColladaLoader.js"></script>
	<script src="vendor/TrackballControls.js"></script>
	<script src="src/main.js"></script>
	<script>
		main.init(update);

		var scene = main.gl.scene,
			camera = main.gl.camera;

		var controls = new THREE.TrackballControls( camera );
		
		var cube = main.gl.makeCube();//,
			//ground = main.gl.makeGround();

		controls.panSpeed = 3.8;
		controls.noRoll = true;
		controls.noRotate = true;
		controls.staticMoving = true;
		//controls.dynamicDampingFactor = 0.3;
		//controls.keys = [ 65, 83, 68 ];

		cube.rotation.y = 0;//0.5;
		cube.position.z = -2
		scene.add(cube);
		//scene.add(ground);

		var posx = 0,
			posz = 0;

		document.addEventListener("dblclick", onMouseDown, false);

		var ambient = new THREE.AmbientLight( 0x666666 );
		scene.add(ambient);
		var directionalLight = new THREE.DirectionalLight( 0x666666 );
		directionalLight.position.set(0, 1000, 500);
		scene.add(directionalLight);

		var manager = new THREE.LoadingManager();
		manager.onProgress = function (item, loaded, total) {
			console.log(item, loaded, total);
		};

		var texture = new THREE.Texture();
		var imgLoader = new THREE.ImageLoader(manager);
		imgLoader.load("textures/UV_Grid_Sm.jpg", function (image) {
			texture.image = image;
			texture.needsUpdate = true;
		});

		var cloader = new THREE.ColladaLoader(),
			groundMesh = null;
		cloader.options.convertUpAxis = true;
		cloader.load( 'obj/lolz.dae', function ( collada ) {

			var dae = collada.scene;

			dae.traverse( function ( child ) {

				if ( child instanceof THREE.Mesh ) {
					child.material.map = texture;
					//var animation = new THREE.Animation( child, child.geometry.animation );
					var scale = 18;
					child.scale.set(scale, scale, scale);
					//animation.play();
					scene.add(child);
					groundMesh = child;
				}

			//dae.updateMatrix();

			//scene.add(dae);

			} );

		});

		var objLoader = new THREE.JSONLoader(manager),
			animation = null;
		objLoader.load('./obj/model.js', function (geometry, materials) {
			var skinnedMesh = new THREE.SkinnedMesh(geometry, new THREE.MeshFaceMaterial(materials));
			skinnedMesh.position.y = 0;
			skinnedMesh.position.z = -5;

			skinnedMesh.scale.set(1, 1, 1);
			scene.add(skinnedMesh);
			 
			animate(skinnedMesh);
		});
		
		var objLoader = new THREE.OBJLoader(manager),
			person = null;

		objLoader.load("obj/female02.obj", function (object) {
			object.traverse( function (child) {
				if (child instanceof THREE.Mesh) {
					child.material.map = texture;
				}
			});
			object.scale.set(0.01, 0.01, 0.01);
			object.position.y = 0.2;
			object.position.z = -2;
			person = object;
			scene.add(object);
		});

		main.run();

		function update() { 
			controls.update();

			//cube.rotation.x += 0.05; 
			cube.rotation.y += 0.05;
			if (person) {
				//person.rotation.x += 0.01;
				//person.position.x += 0.01;
				//person.position.z += 0.01;
				person.translateZ(0.01);
				getIntercectPoint(person, groundMesh);
			}

			if (animation) animation.update(0.06);
		}

		function animate (skinnedMesh) {
			var materials = skinnedMesh.material.materials;		
			for (var k in materials) {
				materials[k].skinning = true;
			}
			animation = new THREE.Animation(skinnedMesh, skinnedMesh.geometry.animation);
			animation.play();
		}

		var raycaster = new THREE.Raycaster();
		function getIntercectPoint(obj, mesh) {
			if (!mesh) return;

			// Cast downwards		
			raycaster.set(obj.position, new THREE.Vector3(0, -1, 0));
			var intersects = raycaster.intersectObject(mesh);

			if (!intersects.length) {
				// Through the floor!
				obj.translateY(0.1);
				return;
			}
			obj.position.set( 0, 1, 0 );
			obj.lookAt(intersects[ 0 ].face.normal);
			obj.position.copy(intersects[ 0 ].point);
		}

		function onMouseDown( event ) {

			var mouseX = ( event.clientX / window.innerWidth ) * 2 - 1;
			var mouseY = -( event.clientY / window.innerHeight ) * 2 + 1;

			var vector = new THREE.Vector3( mouseX, mouseY, camera.near );

			// Convert the [-1, 1] screen coordinate into a world coordinate on the near plane
			var projector = new THREE.Projector();
			projector.unprojectVector(vector, camera);

			var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

			// See if the ray from the camera into the world hits one of our meshes
			var intersects = raycaster.intersectObject( groundMesh );
			//lastIntersects = intersects;

			// Toggle rotation bool for meshes that we clicked
			if ( intersects.length > 0 ) {

				person.position.set( 0, 1, 0 );
				person.lookAt( intersects[ 0 ].face.normal );
				// person.rotation.y -= Math.PI / 2;
				person.position.copy( intersects[ 0 ].point );

			}

		}

	</script>
</body>
</html>