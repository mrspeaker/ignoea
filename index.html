<!DOCTYPE html>
<html>
<head>
	<title>igonea</title>
	<style>
		body {
			margin: 0;
			padding: 0;
		}
		canvas {
			width: 100%;
			height: 100%;
		}
	</style>
</head>
<body>
	<script src="vendor/three.min.js"></script>
	<script src="vendor/OBJLoader.js"></script>
	<script src="vendor/ColladaLoader.js"></script>
	<script src="vendor/TrackballControls.js"></script>
	<script src="src/Entities/Person.js"></script>
	<script src="src/Entities/Cubey.js"></script>
	<script src="src/main.js"></script>
	<script>
		main.init(update);

		var scene = main.gl.scene,
			camera = main.gl.camera;

		var controls = new THREE.TrackballControls( camera );
		controls.panSpeed = 3.8;
		controls.noRoll = true;
		controls.noRotate = true;
		controls.staticMoving = true;
		
		var person = new Person().init([-2, -0.1, -2]),
			p2 = new Person().init([0, -0.1, -10]);

		var cube = new Cubey().init(0, 0, -2);
		
		scene.add(cube.mesh);

		document.addEventListener("dblclick", onMouseDown, false);

		var texture = new THREE.Texture();
		main.loaders.image.load("textures/UV_Grid_Sm.jpg", function (image) {
			texture.image = image;
			texture.needsUpdate = true;
		});

		var groundMesh = null;
		main.loaders.collada.options.convertUpAxis = true;
		main.loaders.collada.load( 'obj/lolz.dae', function ( collada ) {
			var dae = collada.scene;
			dae.traverse( function ( child ) {
				if ( child instanceof THREE.Mesh ) {
					//child.material.map = texture;
					var scale = 52;
					child.scale.set(scale, scale, scale);
					scene.add(child);	
					groundMesh = child;
				}
			} );

		});

		var animation = null;

		main.loaders.object.load('./obj/model.js', function (geometry, materials) {
			var skinnedMesh = new THREE.SkinnedMesh(geometry, new THREE.MeshFaceMaterial(materials));
			skinnedMesh.position.y = 0;
			skinnedMesh.position.z = -5;

			skinnedMesh.scale.set(1, 1, 1);
			scene.add(skinnedMesh);
			 
			animate(skinnedMesh);
		});
		
		[person, p2].forEach(function (p) {
			p.loadMesh(main.manager, texture, function (mesh) {
				scene.add(mesh);
			});
		});

		function update() { 
			controls.update();

			cube.update();
			person.update();
			p2.update();

			[person, p2].forEach(function (p) {
				getIntercectPoint(p.mesh, groundMesh);
			});

			if (animation) animation.update(0.06);
		}

		function animate (skinnedMesh) {
			var materials = skinnedMesh.material.materials;		
			for (var k in materials) {
				materials[k].skinning = true;
			}
			animation = new THREE.Animation(skinnedMesh, skinnedMesh.geometry.animation);
			animation.play();
		}

		var raycaster = new THREE.Raycaster();
		function getIntercectPoint(obj, mesh) {
			if (!mesh) return;

			// Cast downwards
			raycaster.set(obj.position, new THREE.Vector3(0, -1, 0));
			var intersects = raycaster.intersectObject(mesh);
			if (!intersects.length) {
				obj.translateY(0.1);
				return;
			}
			//obj.position.set(0, 1, 0);
			//obj.lookAt(intersects[0].face.normal);
			obj.position.copy(intersects[0].point);
			obj.translateY(0.01); // Move up a tiny bit
			
		}

		function onMouseDown( event ) {

			var mouseX = ( event.clientX / window.innerWidth ) * 2 - 1;
			var mouseY = -( event.clientY / window.innerHeight ) * 2 + 1;

			var vector = new THREE.Vector3( mouseX, mouseY, camera.near );

			// Convert the [-1, 1] screen coordinate into a world coordinate on the near plane
			var projector = new THREE.Projector();
			projector.unprojectVector(vector, camera);

			var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

			// See if the ray from the camera into the world hits one of our meshes
			var intersects = raycaster.intersectObject(groundMesh);
			//lastIntersects = intersects;

			// Toggle rotation bool for meshes that we clicked
			if (intersects.length > 0) {
				//person.position.set(0, 1, 0);
				//person.lookAt(intersects[0].face.normal);
				// // person.rotation.y -= Math.PI / 2;
				//person.position.copy(intersects[0].point);
				person.target = intersects[0].point;
				person.mesh.lookAt(person.target);
			}

		}

	</script>
</body>
</html>